<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>共享状态 - Rust语言圣经(Rust Course)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course/edit/main/src/advance-practice/shared-state.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="共享状态"><a class="header" href="#共享状态">共享状态</a></h1>
<p>上一章节中，咱们搭建了一个异步的 redis 服务器，并成功的提供了服务，但是其隐藏了一个巨大的问题：状态(数据)无法在多个连接之间共享，下面一起来看看该如何解决。</p>
<h2 id="解决方法"><a class="header" href="#解决方法">解决方法</a></h2>
<p>好在 Tokio 十分强大，上面问题对应的解决方法也不止一种：</p>
<ul>
<li>使用 <code>Mutex</code> 来保护数据的共享访问</li>
<li>生成一个异步任务去管理状态，然后各个连接使用消息传递的方式与其进行交互</li>
</ul>
<p>其中，第一种方法适合比较简单的数据，而第二种方法适用于需要异步工作的，例如 I/O 原语。由于我们使用的数据存储类型是 <code>HashMap</code>，使用到的相关操作是 <code>insert</code> 和 <code>get</code> ，又因为这两个操作都不是异步的，因此只要使用 <code>Mutex</code> 即可解决问题。</p>
<p>在上面的描述中，说实话第二种方法及其适用的场景并不是很好理解，但没关系，在后面章节会进行详细介绍。</p>
<h2 id="添加-bytes-依赖包"><a class="header" href="#添加-bytes-依赖包">添加 <code>bytes</code> 依赖包</a></h2>
<p>在上一节中，我们使用 <code>Vec&lt;u8&gt;</code> 来保存目标数据，但是它有一个问题，对它进行克隆时会将底层数据也整个复制一份，效率很低，但是克隆操作对于我们在多连接间共享数据又是必不可少的。</p>
<p>因此这里咱们新引入一个 <code>bytes</code> 包，它包含一个 <code>Bytes</code> 类型，当对该类型的值进行克隆时，就不再会克隆底层数据。事实上，<code>Bytes</code> 是一个引用计数类型，跟 <code>Arc</code> 非常类似，或者准确的说，<code>Bytes</code> 就是基于 <code>Arc</code> 实现的，但相比后者<code>Bytes</code> 提供了一些额外的能力。</p>
<p>在 <code>Cargo.toml</code> 的 <code>[dependencies]</code> 中引入 <code>bytes</code> ：</p>
<pre><code class="language-console">bytes = "1"
</code></pre>
<h2 id="初始化-hashmap"><a class="header" href="#初始化-hashmap">初始化 HashMap</a></h2>
<p>由于 <code>HashMap</code> 会在多个任务甚至多个线程间共享，再结合之前的选择，最终我们决定使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 的方式对其进行包裹。</p>
<p>但是，大家先来畅想一下使用它进行包裹后的类型长什么样？ 大概，可能，长这样：<code>Arc&lt;Mutex&lt;HashMap&lt;String, Bytes&gt;&gt;&gt;</code>，天哪噜，一不小心，你就遇到了 Rust 的阴暗面：类型大串烧。可以想象，如果要在代码中到处使用这样的类型，可读性会极速下降，因此我们需要一个<a href="https://course.rs/advance/custom-type.html#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8Dtype-alias">类型别名</a>( type alias )来简化下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::Bytes;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

type Db = Arc&lt;Mutex&lt;HashMap&lt;String, Bytes&gt;&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p>此时，<code>Db</code> 就是一个类型别名，使用它就可以替代那一大串的东东，等下你就能看到功效。</p>
<p>接着，我们需要在 <code>main</code> 函数中对 <code>HashMap</code> 进行初始化，然后使用 <code>Arc</code> 克隆一份它的所有权并将其传入到生成的异步任务中。事实上在 Tokio 中，这里的 <code>Arc</code> 被称为 <strong>handle</strong>，或者更宽泛的说，<code>handle</code> 在 Tokio 中可以用来访问某个共享状态。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::net::TcpListener;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

#[tokio::main]
async fn main() {
    let listener = TcpListener::bind("127.0.0.1:6379").await.unwrap();

    println!("Listening");

    let db = Arc::new(Mutex::new(HashMap::new()));

    loop {
        let (socket, _) = listener.accept().await.unwrap();
        // 将 handle 克隆一份
        let db = db.clone();

        println!("Accepted");
        tokio::spawn(async move {
            process(socket, db).await;
        });
    }
}</code></pre></pre>
<h4 id="为何使用-stdsyncmutex"><a class="header" href="#为何使用-stdsyncmutex">为何使用 <code>std::sync::Mutex</code></a></h4>
<p>上面代码还有一点非常重要，那就是我们使用了 <code>std::sync::Mutex</code> 来保护 <code>HashMap</code>，而不是使用 <code>tokio::sync::Mutex</code>。</p>
<p>在使用 Tokio 编写异步代码时，一个常见的错误无条件地使用 <code>tokio::sync::Mutex</code> ，而真相是：Tokio 提供的异步锁只应该在跨多个 <code>.await</code>调用时使用，而且 Tokio 的 <code>Mutex</code> 实际上内部使用的也是 <code>std::sync::Mutex</code>。</p>
<p>多补充几句，在异步代码中，关于锁的使用有以下经验之谈：</p>
<ul>
<li>锁如果在多个 <code>.await</code> 过程中持有，应该使用 Tokio 提供的锁，原因是 <code>.await</code>的过程中锁可能在线程间转移，若使用标准库的同步锁存在死锁的可能性，例如某个任务刚获取完锁，还没使用完就因为 <code>.await</code> 让出了当前线程的所有权，结果下个任务又去获取了锁，造成死锁</li>
<li>锁竞争不多的情况下，使用 <code>std::sync::Mutex</code></li>
<li>锁竞争多，可以考虑使用三方库提供的性能更高的锁，例如 <a href="https://docs.rs/parking_lot/0.10.2/parking_lot/type.Mutex.html"><code>parking_lot::Mutex</code></a></li>
</ul>
<h2 id="更新-process"><a class="header" href="#更新-process">更新 <code>process()</code></a></h2>
<p><code>process()</code> 函数不再初始化 <code>HashMap</code>，取而代之的是它使用了 <code>HashMap</code> 的一个 <code>handle</code> 作为参数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpStream;
use mini_redis::{Connection, Frame};

async fn process(socket: TcpStream, db: Db) {
    use mini_redis::Command::{self, Get, Set};

    let mut connection = Connection::new(socket);

    while let Some(frame) = connection.read_frame().await.unwrap() {
        let response = match Command::from_frame(frame).unwrap() {
            Set(cmd) =&gt; {
                let mut db = db.lock().unwrap();
                db.insert(cmd.key().to_string(), cmd.value().clone());
                Frame::Simple("OK".to_string())
            }
            Get(cmd) =&gt; {
                let db = db.lock().unwrap();
                if let Some(value) = db.get(cmd.key()) {
                    Frame::Bulk(value.clone())
                } else {
                    Frame::Null
                }
            }
            cmd =&gt; panic!("unimplemented {:?}", cmd),
        };

        connection.write_frame(&amp;response).await.unwrap();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="任务线程和锁竞争"><a class="header" href="#任务线程和锁竞争">任务、线程和锁竞争</a></h2>
<p>当竞争不多的时候，使用阻塞性的锁去保护共享数据是一个正确的选择。当一个锁竞争触发后，当前正在执行任务(请求锁)的线程会被阻塞，并等待锁被前一个使用者释放。这里的关键就是：<strong>锁竞争不仅仅会导致当前的任务被阻塞，还会导致执行任务的线程被阻塞，因此该线程准备执行的其它任务也会因此被阻塞！</strong></p>
<p>默认情况下，Tokio 调度器使用了多线程模式，此时如果有大量的任务都需要访问同一个锁，那么锁竞争将变得激烈起来。当然，你也可以使用 <a href="https://docs.rs/tokio/1.15.0/tokio/runtime/index.html#current-thread-scheduler"><strong>current_thread</strong></a> 运行时设置，在该设置下会使用一个单线程的调度器(执行器)，所有的任务都会创建并执行在当前线程上，因此不再会有锁竞争。</p>
<blockquote>
<p>current_thread 是一个轻量级、单线程的运行时，当任务数不多或连接数不多时是一个很好的选择。例如你想在一个异步客户端库的基础上提供给用户同步的 API 访问时，该模式就很适用</p>
</blockquote>
<p>当同步锁的竞争变成一个问题时，使用 Tokio 提供的异步锁几乎并不能帮你解决问题，此时可以考虑如下选项：</p>
<ul>
<li>创建专门的任务并使用消息传递的方式来管理状态</li>
<li>将锁进行分片</li>
<li>重构代码以避免锁</li>
</ul>
<p>在我们的例子中，由于每一个 <code>key</code> 都是独立的，因此对锁进行分片将成为一个不错的选择:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type ShardedDb = Arc&lt;Vec&lt;Mutex&lt;HashMap&lt;String, Vec&lt;u8&gt;&gt;&gt;&gt;&gt;;

fn new_sharded_db(num_shards: usize) -&gt; ShardedDb {
    let mut db = Vec::with_capacity(num_shards);
    for _ in 0..num_shards {
        db.push(Mutex::new(HashMap::new()));
    }
    Arc::new(db)
}
<span class="boring">}</span></code></pre></pre>
<p>在这里，我们创建了 N 个不同的存储实例，每个实例都会存储不同的分片数据，例如我们有<code>a-i</code>共 9 个不同的 <code>key</code>, 可以将存储分成 3 个实例，那么第一个实例可以存储 <code>a-c</code>，第二个<code>d-f</code>，以此类推。在这种情况下，访问 <code>b</code> 时，只需要锁住第一个实例，此时二、三实例依然可以正常访问，因此锁被成功的分片了。</p>
<p>在分片后，使用给定的 key 找到对应的值就变成了两个步骤：首先，使用 <code>key</code> 通过特定的算法寻找到对应的分片，然后再使用该 <code>key</code> 从分片中查询到值:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shard = db[hash(key) % db.len()].lock().unwrap();
shard.insert(key, value);
<span class="boring">}</span></code></pre></pre>
<p>这里我们使用 <code>hash</code> 算法来进行分片，但是该算法有个缺陷：分片的数量不能变，一旦变了后，那之前落入分片 1 的<code>key</code>很可能将落入到其它分片中，最终全部乱掉。此时你可以考虑<a href="https://docs.rs/dashmap">dashmap</a>，它提供了更复杂、更精妙的支持分片的<code>hash map</code>。</p>
<h2 id="在-await-期间持有锁"><a class="header" href="#在-await-期间持有锁">在 <code>.await</code> 期间持有锁</a></h2>
<p>在某些时候，你可能会不经意写下这种代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Mutex, MutexGuard};

async fn increment_and_do_stuff(mutex: &amp;Mutex&lt;i32&gt;) {
    let mut lock: MutexGuard&lt;i32&gt; = mutex.lock().unwrap();
    *lock += 1;

    do_something_async().await;
} // 锁在这里超出作用域
<span class="boring">}</span></code></pre></pre>
<p>如果你要 <code>spawn</code> 一个任务来执行上面的函数的话，会报错:</p>
<pre><code class="language-console">error: future cannot be sent between threads safely
   --&gt; src/lib.rs:13:5
    |
13  |     tokio::spawn(async move {
    |     ^^^^^^^^^^^^ future created by async block is not `Send`
    |
   ::: /playground/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-0.2.21/src/task/spawn.rs:127:21
    |
127 |         T: Future + Send + 'static,
    |                     ---- required by this bound in `tokio::task::spawn::spawn`
    |
    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&lt;'_, i32&gt;`
note: future is not `Send` as this value is used across an await
   --&gt; src/lib.rs:7:5
    |
4   |     let mut lock: MutexGuard&lt;i32&gt; = mutex.lock().unwrap();
    |         -------- has type `std::sync::MutexGuard&lt;'_, i32&gt;` which is not `Send`
...
7   |     do_something_async().await;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ await occurs here, with `mut lock` maybe used later
8   | }
    | - `mut lock` is later dropped here
</code></pre>
<p>错误的原因在于 <code>std::sync::MutexGuard</code> 类型并没有实现 <code>Send</code> 特征，这意味着你不能将一个 <code>Mutex</code> 锁发送到另一个线程，因为 <code>.await</code> 可能会让任务转移到另一个线程上执行，这个之前也介绍过。</p>
<h4 id="提前释放锁"><a class="header" href="#提前释放锁">提前释放锁</a></h4>
<p>要解决这个问题，就必须重构代码，让 <code>Mutex</code> 锁在 <code>.await</code> 被调用前就被释放掉。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 下面的代码可以工作！
async fn increment_and_do_stuff(mutex: &amp;Mutex&lt;i32&gt;) {
    {
        let mut lock: MutexGuard&lt;i32&gt; = mutex.lock().unwrap();
        *lock += 1;
    } // lock在这里超出作用域 (被释放)

    do_something_async().await;
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>大家可能已经发现，很多错误都是因为 <code>.await</code> 引起的，其实你只要记住，在 <code>.await</code> 执行期间，任务可能会在线程间转移，那么这些错误将变得很好理解，不必去死记硬背</p>
</blockquote>
<p>但是下面的代码不工作：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Mutex, MutexGuard};

async fn increment_and_do_stuff(mutex: &amp;Mutex&lt;i32&gt;) {
    let mut lock: MutexGuard&lt;i32&gt; = mutex.lock().unwrap();
    *lock += 1;
    drop(lock);

    do_something_async().await;
}
<span class="boring">}</span></code></pre></pre>
<p>原因我们之前解释过，编译器在这里不够聪明，目前它只能根据作用域的范围来判断，<code>drop</code> 虽然释放了锁，但是锁的作用域依然会持续到函数的结束，未来也许编译器会改进，但是现在至少还是不行的。</p>
<p>聪明的读者此时的小脑袋已经飞速运转起来，既然锁没有实现 <code>Send</code>， 那我们主动给它实现如何？这样不就可以顺利运行了吗？答案依然是不可以，原因就是我们之前提到过的死锁，如果一个任务获取了锁，然后还没释放就在 <code>.await</code> 期间被挂起，接着开始执行另一个任务，这个任务又去获取锁，就会导致死锁。</p>
<p>再来看看其它解决方法：</p>
<h4 id="重构代码在-await-期间不持有锁"><a class="header" href="#重构代码在-await-期间不持有锁">重构代码：在 <code>.await</code> 期间不持有锁</a></h4>
<p>之前的代码其实也是为了在 <code>.await</code> 期间不持有锁，但是我们还有更好的实现方式，例如，你可以把 <code>Mutex</code> 放入一个结构体中，并且只在该结构体的非异步方法中使用该锁:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct CanIncrement {
    mutex: Mutex&lt;i32&gt;,
}
impl CanIncrement {
    // 该方法不是 `async`
    fn increment(&amp;self) {
        let mut lock = self.mutex.lock().unwrap();
        *lock += 1;
    }
}

async fn increment_and_do_stuff(can_incr: &amp;CanIncrement) {
    can_incr.increment();
    do_something_async().await;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="使用异步任务和通过消息传递来管理状态"><a class="header" href="#使用异步任务和通过消息传递来管理状态">使用异步任务和通过消息传递来管理状态</a></h4>
<p>该方法常常用于共享的资源是 I/O 类型的资源时，我们在下一章节将详细介绍。</p>
<h4 id="使用-tokio-提供的异步锁"><a class="header" href="#使用-tokio-提供的异步锁">使用 Tokio 提供的异步锁</a></h4>
<p>Tokio 提供的锁最大的优点就是：它可以在 <code>.await</code> 执行期间被持有，而且不会有任何问题。但是代价就是，这种异步锁的性能开销会更高，因此如果可以，使用之前的两种方法来解决会更好。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::Mutex; // 注意，这里使用的是 Tokio 提供的锁

// 下面的代码会编译
// 但是就这个例子而言，之前的方式会更好
async fn increment_and_do_stuff(mutex: &amp;Mutex&lt;i32&gt;) {
    let mut lock = mutex.lock().await;
    *lock += 1;

    do_something_async().await;
} // 锁在这里被释放
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../advance-practice/spawning.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../advance-practice/channels.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../advance-practice/spawning.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../advance-practice/channels.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../assets/custom.js"></script>
        <script src="../assets/bigPicture.js"></script>


    </div>
    </body>
</html>
