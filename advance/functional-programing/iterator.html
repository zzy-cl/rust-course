<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>迭代器 Iterator - Rust语言圣经(Rust Course)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/style.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course/edit/main/src/advance/functional-programing/iterator.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="迭代器-iterator"><a class="header" href="#迭代器-iterator">迭代器 Iterator</a></h1>
<p>如果你询问一个 Rust 资深开发：写 Rust 项目最需要掌握什么？相信迭代器往往就是答案之一。无论你是编程新手亦或是高手，实际上大概率都用过迭代器，虽然自己可能并没有意识到这一点:)</p>
<p>迭代器允许我们迭代一个连续的集合，例如数组、动态数组 <code>Vec</code>、<code>HashMap</code> 等，在此过程中，只需关心集合中的元素如何处理，而无需关心如何开始、如何结束、按照什么样的索引去访问等问题。</p>
<h2 id="for-循环与迭代器"><a class="header" href="#for-循环与迭代器">For 循环与迭代器</a></h2>
<p>从用途来看，迭代器跟 <code>for</code> 循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：<strong>是否通过索引来访问集合</strong>。</p>
<p>例如以下的 JS 代码就是一个循环：</p>
<pre><code class="language-javascript">let arr = [1, 2, 3];
for (let i = 0; i &lt; arr.length; i++) {
  console.log(arr[i]);
}
</code></pre>
<p>在上面代码中，我们设置索引的开始点和结束点，然后再通过索引去访问元素 <code>arr[i]</code>，这就是典型的循环，来对比下 Rust 中的 <code>for</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];
for v in arr {
    println!("{}",v);
}
<span class="boring">}</span></code></pre></pre>
<p>首先，不得不说这两语法还挺像！与 JS 循环不同，<code>Rust</code>中没有使用索引，它把 <code>arr</code> 数组当成一个迭代器，直接去遍历其中的元素，从哪里开始，从哪里结束，都无需操心。因此严格来说，Rust 中的 <code>for</code> 循环是编译器提供的语法糖，最终还是对迭代器中的元素进行遍历。</p>
<p>那又有同学要发问了，在 Rust 中数组是迭代器吗？因为在之前的代码中直接对数组 <code>arr</code> 进行了迭代，答案是 <code>No</code>。那既然数组不是迭代器，为啥咱可以对它的元素进行迭代呢？</p>
<p>简而言之就是数组实现了 <code>IntoIterator</code> 特征，Rust 通过 <code>for</code> 语法糖，自动把实现了该特征的数组类型转换为迭代器（你也可以为自己的集合类型实现此特征），最终让我们可以直接对一个数组进行迭代，类似的还有：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..10 {
    println!("{}", i);
}
<span class="boring">}</span></code></pre></pre>
<p>直接对数值序列进行迭代，也是很常见的使用方式。</p>
<p><code>IntoIterator</code> 特征拥有一个 <code>into_iter</code> 方法，因此我们还可以显式的把数组转换成迭代器：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];
for v in arr.into_iter() {
    println!("{}", v);
}
<span class="boring">}</span></code></pre></pre>
<p>迭代器是函数语言的核心特性，它赋予了 Rust 远超于循环的强大表达能力，我们将在本章中一一为大家进行展现。</p>
<h2 id="惰性初始化"><a class="header" href="#惰性初始化">惰性初始化</a></h2>
<p>在 Rust 中，迭代器是惰性的，意味着如果你不使用它，那么它将不会发生任何事：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("{}", val);
}
<span class="boring">}</span></code></pre></pre>
<p>在 <code>for</code> 循环之前，我们只是简单的创建了一个迭代器 <code>v1_iter</code>，此时不会发生任何迭代行为，只有在 <code>for</code> 循环开始后，迭代器才会开始迭代其中的元素，最后打印出来。</p>
<p>这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。</p>
<h2 id="next-方法"><a class="header" href="#next-方法">next 方法</a></h2>
<p>对于 <code>for</code> 如何遍历迭代器，还有一个问题，它如何取出迭代器中的元素？</p>
<p>先来看一个特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 省略其余有默认实现的方法
}
<span class="boring">}</span></code></pre></pre>
<p>呦，该特征竟然和迭代器 <code>iterator</code> 同名，难不成。。。没错，它们就是有一腿。<strong>迭代器之所以成为迭代器，就是因为实现了 <code>Iterator</code> 特征</strong>，要实现该特征，最主要的就是实现其中的 <code>next</code> 方法，该方法控制如何从集合中取值，最终返回值的类型是<a href="https://course.rs/basic/trait/advance-trait#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a> <code>Item</code>。</p>
<p>因此，之前问题的答案已经很明显：<code>for</code> 循环通过不停调用迭代器上的 <code>next</code> 方法，来获取迭代器中的元素。</p>
<p>既然 <code>for</code> 可以调用 <code>next</code> 方法，是不是意味着我们也可以？来试试：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let arr = [1, 2, 3];
    let mut arr_iter = arr.into_iter();

    assert_eq!(arr_iter.next(), Some(1));
    assert_eq!(arr_iter.next(), Some(2));
    assert_eq!(arr_iter.next(), Some(3));
    assert_eq!(arr_iter.next(), None);
}</code></pre></pre>
<p>果不其然，将 <code>arr</code> 转换成迭代器后，通过调用其上的 <code>next</code> 方法，我们获取了 <code>arr</code> 中的元素，有两点需要注意：</p>
<ul>
<li><code>next</code> 方法返回的是 <code>Option</code> 类型，当有值时返回 <code>Some(i32)</code>，无值时返回 <code>None</code></li>
<li>遍历是按照迭代器中元素的排列顺序依次进行的，因此我们严格按照数组中元素的顺序取出了 <code>Some(1)</code>，<code>Some(2)</code>，<code>Some(3)</code></li>
<li>手动迭代必须将迭代器声明为 <code>mut</code> 可变，因为调用 <code>next</code> 会改变迭代器其中的状态数据（当前遍历的位置等），而 <code>for</code> 循环去迭代则无需标注 <code>mut</code>，因为它会帮我们自动完成</li>
</ul>
<p>总之，<code>next</code> 方法对<strong>迭代器的遍历是消耗性的</strong>，每次消耗它一个元素，最终迭代器中将没有任何元素，只能返回 <code>None</code>。</p>
<h4 id="例子模拟实现-for-循环"><a class="header" href="#例子模拟实现-for-循环">例子：模拟实现 for 循环</a></h4>
<p>因为 <code>for</code> 循环是迭代器的语法糖，因此我们完全可以通过迭代器来模拟实现它：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![1, 2, 3];

{
    let result = match IntoIterator::into_iter(values) {
        mut iter =&gt; loop {
            match iter.next() {
                Some(x) =&gt; { println!("{}", x); },
                None =&gt; break,
            }
        },
    };
    result
}
<span class="boring">}</span></code></pre></pre>
<p><code>IntoIterator::into_iter</code> 是使用<a href="https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95">完全限定</a>的方式去调用 <code>into_iter</code> 方法，这种调用方式跟 <code>values.into_iter()</code> 是等价的。</p>
<p>同时我们使用了 <code>loop</code> 循环配合 <code>next</code> 方法来遍历迭代器中的元素，当迭代器返回 <code>None</code> 时，跳出循环。</p>
<h2 id="intoiterator-特征"><a class="header" href="#intoiterator-特征">IntoIterator 特征</a></h2>
<p>其实有一个细节，由于 <code>Vec</code> 动态数组实现了 <code>IntoIterator</code> 特征，因此可以通过 <code>into_iter</code> 将其转换为迭代器，那如果本身就是一个迭代器，该怎么办？实际上，迭代器自身也实现了 <code>IntoIterator</code>，标准库早就帮我们考虑好了：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;I: Iterator&gt; IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    #[inline]
    fn into_iter(self) -&gt; I {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>最终你完全可以写出这样的奇怪代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter().into_iter().into_iter() {
        println!("{}",v)
    }
}</code></pre></pre>
<h4 id="into_iter-iter-iter_mut"><a class="header" href="#into_iter-iter-iter_mut">into_iter, iter, iter_mut</a></h4>
<p>在之前的代码中，我们统一使用了 <code>into_iter</code> 的方式将数组转化为迭代器，除此之外，还有 <code>iter</code> 和 <code>iter_mut</code>，聪明的读者应该大概能猜到这三者的区别：</p>
<ul>
<li><code>into_iter</code> 会夺走所有权</li>
<li><code>iter</code> 是借用</li>
<li><code>iter_mut</code> 是可变借用</li>
</ul>
<p>其实如果以后见多识广了，你会发现这种问题一眼就能看穿，<code>into_</code> 之类的，都是拿走所有权，<code>_mut</code> 之类的都是可变借用，剩下的就是不可变借用。</p>
<p>使用一段代码来解释下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter() {
        println!("{}", v)
    }

    // 下面的代码将报错，因为 values 的所有权在上面 `for` 循环中已经被转移走
    // println!("{:?}",values);

    let values = vec![1, 2, 3];
    let _values_iter = values.iter();

    // 不会报错，因为 values_iter 只是借用了 values 中的元素
    println!("{:?}", values);

    let mut values = vec![1, 2, 3];
    // 对 values 中的元素进行可变借用
    let mut values_iter_mut = values.iter_mut();

    // 取出第一个元素，并修改为0
    if let Some(v) = values_iter_mut.next() {
        *v = 0;
    }

    // 输出[0, 2, 3]
    println!("{:?}", values);
}</code></pre></pre>
<p>具体解释在代码注释中，就不再赘述，不过有两点需要注意的是：</p>
<ul>
<li><code>.iter()</code> 方法实现的迭代器，调用 <code>next</code> 方法返回的类型是 <code>Some(&amp;T)</code></li>
<li><code>.iter_mut()</code> 方法实现的迭代器，调用 <code>next</code> 方法返回的类型是 <code>Some(&amp;mut T)</code>，因此在 <code>if let Some(v) = values_iter_mut.next()</code> 中，<code>v</code> 的类型是 <code>&amp;mut i32</code>，最终我们可以通过 <code>*v = 0</code> 的方式修改其值</li>
</ul>
<h4 id="iterator-和-intoiterator-的区别"><a class="header" href="#iterator-和-intoiterator-的区别">Iterator 和 IntoIterator 的区别</a></h4>
<p>这两个其实还蛮容易搞混的，但我们只需要记住，<code>Iterator</code> 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 <code>next</code>。</p>
<p>而 <code>IntoIterator</code> 强调的是某一个类型如果实现了该特征，它可以通过 <code>into_iter</code>，<code>iter</code> 等方法变成一个迭代器。</p>
<h2 id="消费者与适配器"><a class="header" href="#消费者与适配器">消费者与适配器</a></h2>
<p>消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖 <code>next</code> 方法来消费元素，因此这也是为什么迭代器要实现 <code>Iterator</code> 特征，而该特征必须要实现 <code>next</code> 方法的原因。</p>
<h4 id="消费者适配器"><a class="header" href="#消费者适配器">消费者适配器</a></h4>
<p>只要迭代器上的某个方法 <code>A</code> 在其内部调用了 <code>next</code> 方法，那么 <code>A</code> 就被称为<strong>消费性适配器</strong>：因为 <code>next</code> 方法会消耗掉迭代器上的元素，所以方法 <code>A</code> 的调用也会消耗掉迭代器上的元素。</p>
<p>其中一个例子是 <code>sum</code> 方法，它会拿走迭代器的所有权，然后通过不断调用 <code>next</code> 方法对里面的元素进行求和：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);

    // v1_iter 是借用了 v1，因此 v1 可以照常使用
    println!("{:?}",v1);

    // 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权
    // println!("{:?}",v1_iter);
}</code></pre></pre>
<p>如代码注释中所说明的：在使用 <code>sum</code> 方法后，我们将无法再使用 <code>v1_iter</code>，因为 <code>sum</code> 拿走了该迭代器的所有权：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum&lt;S&gt;(self) -&gt; S
    where
        Self: Sized,
        S: Sum&lt;Self::Item&gt;,
    {
        Sum::sum(self)
    }

<span class="boring">}</span></code></pre></pre>
<p>从 <code>sum</code> 源码中也可以清晰看出，<code>self</code> 类型的方法参数拿走了所有权。</p>
<h4 id="迭代器适配器"><a class="header" href="#迭代器适配器">迭代器适配器</a></h4>
<p>既然消费者适配器是消费掉迭代器，然后返回一个值。那么迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键：<code>v.iter().map().filter()...</code>。</p>
<p>与消费者适配器不同，迭代器适配器是惰性的，意味着你<strong>需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值</strong>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p>运行后输出:</p>
<pre><code class="language-console">warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed // 迭代器 map 是惰性的，这里不产生任何效果
</code></pre>
<p>如上述中文注释所说，这里的 <code>map</code> 方法是一个迭代者适配器，它是惰性的，不产生任何行为，因此我们还需要一个消费者适配器进行收尾：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<h4 id="collect"><a class="header" href="#collect">collect</a></h4>
<p>上面代码中，使用了 <code>collect</code> 方法，该方法就是一个消费者适配器，使用它可以将一个迭代器中的元素收集到指定类型中，这里我们为 <code>v2</code> 标注了 <code>Vec&lt;_&gt;</code> 类型，就是为了告诉 <code>collect</code>：请把迭代器中的元素消费掉，然后把值收集成 <code>Vec&lt;_&gt;</code> 类型，至于为何使用 <code>_</code>，因为编译器会帮我们自动推导。</p>
<p>为何 <code>collect</code> 在消费时要指定类型？是因为该方法其实很强大，可以收集成多种不同的集合类型，<code>Vec&lt;T&gt;</code> 仅仅是其中之一，因此我们必须显式的告诉编译器我们想要收集成的集合类型。</p>
<p>还有一点值得注意，<code>map</code> 会对迭代器中的每一个值进行一系列操作，然后把该值转换成另外一个新值，该操作是通过闭包 <code>|x| x + 1</code> 来完成：最终迭代器中的每个值都增加了 <code>1</code>，从 <code>[1, 2, 3]</code> 变为 <code>[2, 3, 4]</code>。</p>
<p>再来看看如何使用 <code>collect</code> 收集成 <code>HashMap</code> 集合：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
fn main() {
    let names = ["sunface", "sunfei"];
    let ages = [18, 18];
    let folks: HashMap&lt;_, _&gt; = names.into_iter().zip(ages.into_iter()).collect();

    println!("{:?}",folks);
}</code></pre></pre>
<p><code>zip</code> 是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成 <code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code> 这样的新的迭代器，在此处就是形如 <code>[(name1, age1), (name2, age2)]</code> 的迭代器。</p>
<p>然后再通过 <code>collect</code> 将新迭代器中<code>(K, V)</code> 形式的值收集成 <code>HashMap&lt;K, V&gt;</code>，同样的，这里必须显式声明类型，然后 <code>HashMap</code> 内部的 <code>KV</code> 类型可以交给编译器去推导，最终编译器会推导出 <code>HashMap&lt;&amp;str, i32&gt;</code>，完全正确！</p>
<h4 id="闭包作为适配器参数"><a class="header" href="#闭包作为适配器参数">闭包作为适配器参数</a></h4>
<p>之前的 <code>map</code> 方法中，我们使用闭包来作为迭代器适配器的参数，它最大的好处不仅在于可以就地实现迭代器中元素的处理，还在于可以捕获环境值：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
<span class="boring">}</span></code></pre></pre>
<p><code>filter</code> 是迭代器适配器，用于对迭代器中的每个值进行过滤。 它使用闭包作为参数，该闭包的参数 <code>s</code> 是来自迭代器中的值，然后使用 <code>s</code> 跟外部环境中的 <code>shoe_size</code> 进行比较，若相等，则在迭代器中保留 <code>s</code> 值，若不相等，则从迭代器中剔除 <code>s</code> 值，最终通过 <code>collect</code> 收集为 <code>Vec&lt;Shoe&gt;</code> 类型。</p>
<h2 id="实现-iterator-特征"><a class="header" href="#实现-iterator-特征">实现 Iterator 特征</a></h2>
<p>之前的内容我们一直基于数组来创建迭代器，实际上，不仅仅是数组，基于其它集合类型一样可以创建迭代器，例如 <code>HashMap</code>。 你也可以创建自己的迭代器 —— 只要为自定义类型实现 <code>Iterator</code> 特征即可。</p>
<p>首先，创建一个计数器：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>我们为计数器 <code>Counter</code> 实现了一个关联函数 <code>new</code>，用于创建新的计数器实例。下面我们继续为计数器实现 <code>Iterator</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>首先，将该特征的关联类型设置为 <code>u32</code>，由于我们的计数器保存的 <code>count</code> 字段就是 <code>u32</code> 类型， 因此在 <code>next</code> 方法中，最后返回的是实际上是 <code>Option&lt;u32&gt;</code> 类型。</p>
<p>每次调用 <code>next</code> 方法，都会让计数器的值加一，然后返回最新的计数值，一旦计数大于 5，就返回 <code>None</code>。</p>
<p>最后，使用我们新建的 <code>Counter</code> 进行迭代：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
<span class="boring">}</span></code></pre></pre>
<h4 id="实现-iterator-特征的其它方法"><a class="header" href="#实现-iterator-特征的其它方法">实现 Iterator 特征的其它方法</a></h4>
<p>可以看出，实现自己的迭代器非常简单，但是 <code>Iterator</code> 特征中，不仅仅是只有 <code>next</code> 一个方法，那为什么我们只需要实现它呢？因为其它方法都具有<a href="https://course.rs/basic/trait/trait.html#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">默认实现</a>，所以无需像 <code>next</code> 这样手动去实现，而且这些默认实现的方法其实都是基于 <code>next</code> 方法实现的。</p>
<p>下面的代码演示了部分方法的使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum: u32 = Counter::new()
    .zip(Counter::new().skip(1))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
assert_eq!(18, sum);
<span class="boring">}</span></code></pre></pre>
<p>其中 <code>zip</code>，<code>map</code>，<code>filter</code> 是迭代器适配器：</p>
<ul>
<li><code>zip</code> 把两个迭代器合并成一个迭代器，新迭代器中，每个元素都是一个元组，由之前两个迭代器的元素组成。例如将<strong>形如</strong> <code>[1, 2, 3, 4, 5]</code> 和 <code>[2, 3, 4, 5]</code> 的迭代器合并后，新的迭代器形如 <code>[(1, 2),(2, 3),(3, 4),(4, 5)]</code></li>
<li><code>map</code> 是将迭代器中的值经过映射后，转换成新的值[2, 6, 12, 20]</li>
<li><code>filter</code> 对迭代器中的元素进行过滤，若闭包返回 <code>true</code> 则保留元素[6, 12]，反之剔除</li>
</ul>
<p>而 <code>sum</code> 是消费者适配器，对迭代器中的所有元素求和，最终返回一个 <code>u32</code> 值 <code>18</code>。</p>
<h5 id="enumerate"><a class="header" href="#enumerate">enumerate</a></h5>
<p>在之前的流程控制章节，针对 <code>for</code> 循环，我们提供了一种方法可以获取迭代时的索引：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1u64, 2, 3, 4, 5, 6];
for (i,v) in v.iter().enumerate() {
    println!("第{}个值是{}",i,v)
}
<span class="boring">}</span></code></pre></pre>
<p>相信当时，很多读者还是很迷茫的，不知道为什么要这么复杂才能获取到索引，学习本章节后，相信你有了全新的理解，首先 <code>v.iter()</code> 创建迭代器，其次
调用 <code>Iterator</code> 特征上的方法 <code>enumerate</code>，该方法产生一个新的迭代器，其中每个元素均是元组 <code>(索引，值)</code>。</p>
<p>因为 <code>enumerate</code> 是迭代器适配器，因此我们可以对它返回的迭代器调用其它 <code>Iterator</code> 特征方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1u64, 2, 3, 4, 5, 6];
let val = v.iter()
    .enumerate()
    // 每两个元素剔除一个
    // [1, 3, 5]
    .filter(|&amp;(idx, _)| idx % 2 == 0)
    .map(|(_, val)| val)
    // 累加 1+3+5 = 9
    .fold(0u64, |sum, acm| sum + acm);

println!("{}", val);
<span class="boring">}</span></code></pre></pre>
<h2 id="迭代器的性能"><a class="header" href="#迭代器的性能">迭代器的性能</a></h2>
<p>前面提到，要完成集合遍历，既可以使用 <code>for</code> 循环也可以使用迭代器，那么二者之间该怎么选择呢，性能有多大差距呢？</p>
<p>理论分析不会有结果，直接测试最为靠谱：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate rand;
extern crate test;

fn sum_for(x: &amp;[f64]) -&gt; f64 {
    let mut result: f64 = 0.0;
    for i in 0..x.len() {
        result += x[i];
    }
    result
}

fn sum_iter(x: &amp;[f64]) -&gt; f64 {
    x.iter().sum::&lt;f64&gt;()
}

#[cfg(test)]
mod bench {
    use test::Bencher;
    use rand::{Rng,thread_rng};
    use super::*;

    const LEN: usize = 1024*1024;

    fn rand_array(cnt: u32) -&gt; Vec&lt;f64&gt; {
        let mut rng = thread_rng();
        (0..cnt).map(|_| rng.gen::&lt;f64&gt;()).collect()
    }

    #[bench]
    fn bench_for(b: &amp;mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_for(&amp;samples)
        })
    }

    #[bench]
    fn bench_iter(b: &amp;mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_iter(&amp;samples)
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>上面的代码对比了 <code>for</code> 循环和迭代器 <code>iterator</code> 完成同样的求和任务的性能对比，可以看到迭代器还要更快一点。</p>
<pre><code class="language-console">test bench::bench_for  ... bench:     998,331 ns/iter (+/- 36,250)
test bench::bench_iter ... bench:     983,858 ns/iter (+/- 44,673)
</code></pre>
<p>迭代器是 Rust 的 <strong>零成本抽象</strong>（zero-cost abstractions）之一，意味着抽象并不会引入运行时开销，这与 <code>Bjarne Stroustrup</code>（C++ 的设计和实现者）在 <code>Foundations of C++（2012）</code> 中所定义的 <strong>零开销</strong>（zero-overhead）如出一辙：</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for.
And further: What you do use, you couldn’t hand code any better.</p>
<p>一般来说，C++的实现遵循零开销原则：没有使用时，你不必为其买单。
更进一步说，需要使用时，你也无法写出更优的代码了。
（翻译一下：用就完事了）</p>
</blockquote>
<p>总之，迭代器是 Rust 受函数式语言启发而提供的高级语言特性，可以写出更加简洁、逻辑清晰的代码。编译器还可以通过循环展开（Unrolling）、向量化、消除边界检查等优化手段，使得迭代器和 <code>for</code> 循环都有极为高效的执行效率。</p>
<p>所以请放心大胆的使用迭代器，在获得更高的表达力的同时，也不会导致运行时的损失，何乐而不为呢！</p>
<h2 id="学习其它方法"><a class="header" href="#学习其它方法">学习其它方法</a></h2>
<p>迭代器用的好不好，就在于你是否掌握了它的常用方法，且能活学活用，因此多多看看<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">标准库</a>是有好处的，只有知道有什么方法，在需要的时候你才能知道该用什么，就和算法学习一样。</p>
<p>同时，本书在后续章节还提供了对迭代器常用方法的<a href="https://course.rs/std/iterator">深入讲解</a>，方便大家学习和查阅。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../advance/functional-programing/closure.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../advance/into-types/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../advance/functional-programing/closure.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../advance/into-types/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../assets/custom.js"></script>
        <script src="../../assets/bigPicture.js"></script>


    </div>
    </body>
</html>
